use std::f64::consts::PI;
use std::fs::read_to_string;
use std::io::Write;
use std::path::Path;
use std::process::Command;
use std::{error::Error, fs::File};

use nalgebra::{ComplexField, DMatrix, SquareMatrix};
use tempfile::TempDir;

use crate::MainApp;

const TEMP_SCRIPT_NAME: &str = "linearize.mos";

pub fn start_analysis(app: &MainApp) -> Result<ModalResult, Box<dyn Error>> {
    let tempdir = TempDir::new()?;
    let mut script = File::create(tempdir.path().join(TEMP_SCRIPT_NAME))?;

    let model_path = Path::new(&app.model_path);
    if !model_path.exists() {
        return Err("Could not find file for given model path!".into());
    }

    writeln!(script, "loadFile(\"{}\");", &app.model_path)?;
    writeln!(script, "linearize({}, stopTime=0.0);", &app.model_name)?;
    writeln!(script, "getErrorString();")?;

    let _ = Command::new(&app.omc_path)
        .current_dir(tempdir.path())
        .arg(TEMP_SCRIPT_NAME)
        .output()?;

    // read and parse `linearized_model.mo`

    let linearized_model = read_to_string(tempdir.path().join("linearized_model.mo"))?;

    ModalResult::from_linearized_model(&linearized_model)
}

pub struct ModalResult {
    pub a_matrix: DMatrix<f64>,
}

impl ModalResult {
    pub fn from_linearized_model(model_content: &str) -> Result<Self, Box<dyn Error>> {
        Ok(Self {
            a_matrix: parse_modelica_a_matrix(model_content)?,
        })
    }

    pub fn eigenfreqs(&self) -> Vec<f64> {
        self.a_matrix
            .complex_eigenvalues()
            .iter()
            .map(|lambda| lambda.abs() / (2. * PI))
            .collect()
    }
    pub fn dampened_eigenfreqs(&self) -> Vec<f64> {
        self.a_matrix
            .complex_eigenvalues()
            .iter()
            .map(|lambda| lambda.im / (2. * PI))
            .collect()
    }
}

use regex::Regex;
/// The point of this function is to extract the A Matrix from the `linearized_model.mo` file
/// that gets automatically generated by the OM Compiler when requesting a linearization.
fn parse_modelica_a_matrix(content: &str) -> Result<DMatrix<f64>, Box<dyn Error>> {
    let re = Regex::new(r"(?s)parameter\s+Real\s+A\[n,\s*n\]\s*=\s*\[(.*?)\];")?;

    let caps = re
        .captures(content)
        .ok_or("Could not find an A-Matrix definition inside the linearized model file.")?;

    let matrix_str = &caps[1];

    let rows: Vec<&str> = matrix_str
        .split(';')
        .map(|s| s.trim())
        .filter(|s| !s.is_empty())
        .collect();

    let row_count = rows.len();
    if row_count == 0 {
        return Err("A-Matrix appears to be empty.".into());
    }

    let mut data = Vec::new();
    let mut col_count = 0;

    for (i, row) in rows.iter().enumerate() {
        let cols: Vec<f64> = row
            .split(',')
            .map(|val| val.trim().parse::<f64>())
            .collect::<Result<Vec<_>, _>>()?;

        if i == 0 {
            col_count = cols.len();
        } else if cols.len() != col_count {
            return Err(format!("Inconsistent number of columns in line {}", i).into());
        }

        data.extend(cols);
    }

    // Explicit check for squareness
    if row_count != col_count {
        return Err(format!(
            "Matrix is not square ({}x{}). An A-matrix must be square for eigenvalue analysis.",
            row_count, col_count
        )
        .into());
    }

    // DMatrix is dynamic but satisfies SquareMatrix traits if row_count == col_count
    Ok(DMatrix::from_row_slice(row_count, col_count, &data))
}

// /home/qhuss/Dokumente/GitHub/om_modal/examples/pendel.mo
