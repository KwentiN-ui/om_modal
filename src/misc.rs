use std::f64::consts::PI;
use std::fs::read_to_string;
use std::io::Write;
use std::path::Path;
use std::process::Command;
use std::{error::Error, fs::File};

use nalgebra::{ComplexField, DMatrix};
use serde::{Deserialize, Serialize};
use tempfile::TempDir;

use crate::MainApp;

const TEMP_SCRIPT_NAME: &str = "linearize.mos";

pub fn start_analysis(app: &MainApp) -> Result<Vec<EigenMode>, Box<dyn Error>> {
    let tempdir = TempDir::new()?;
    let mut script = File::create(tempdir.path().join(TEMP_SCRIPT_NAME))?;

    let model_path = Path::new(&app.model_path);
    if !model_path.exists() {
        return Err("Could not find file for given model path!".into());
    }

    writeln!(script, "loadFile(\"{}\");", &app.model_path)?;
    writeln!(script, "linearize({}, stopTime=0.0);", &app.model_name)?;
    writeln!(script, "getErrorString();")?;

    let _ = Command::new(&app.omc_path)
        .current_dir(tempdir.path())
        .arg(TEMP_SCRIPT_NAME)
        .output()?;

    // read and parse `linearized_model.mo`
    let linearized_model = read_to_string(tempdir.path().join("linearized_model.mo"))?;

    EigenMode::from_linearized_model(&linearized_model)
}

#[derive(Debug, Clone, Default, Serialize, Deserialize)]
pub struct EigenMode {
    pub i: usize,
    pub re: f64,
    pub im: f64,
    pub eigenvalue: f64,
    pub eigenfreq: f64,
    pub eigenfreq_dampened: f64,
}

impl EigenMode {
    pub fn from_linearized_model(model_content: &str) -> Result<Vec<Self>, Box<dyn Error>> {
        let a_matrix = parse_modelica_a_matrix(model_content)?;
        let lambda_cmplx = a_matrix.complex_eigenvalues();

        let modes = lambda_cmplx
            .iter()
            .step_by(2)
            .enumerate()
            .map(|(i, lambda)| Self {
                i: i + 1,
                re: lambda.re,
                im: lambda.im,
                eigenvalue: lambda.abs(),
                eigenfreq: lambda.abs() / (2. * PI),
                eigenfreq_dampened: lambda.im / (2. * PI),
            })
            .collect();
        Ok(modes)
    }
}

use regex::Regex;
/// The point of this function is to extract the A Matrix from the `linearized_model.mo` file
/// that gets automatically generated by the OM Compiler when requesting a linearization.
fn parse_modelica_a_matrix(content: &str) -> Result<DMatrix<f64>, Box<dyn Error>> {
    let re = Regex::new(r"(?s)parameter\s+Real\s+A\[n,\s*n\]\s*=\s*\[(.*?)\];")?;

    let caps = re
        .captures(content)
        .ok_or("Could not find an A-Matrix definition inside the linearized model file.")?;

    let matrix_str = &caps[1];

    let rows: Vec<&str> = matrix_str
        .split(';')
        .map(|s| s.trim())
        .filter(|s| !s.is_empty())
        .collect();

    let row_count = rows.len();
    if row_count == 0 {
        return Err("A-Matrix appears to be empty.".into());
    }

    let mut data = Vec::new();
    let mut col_count = 0;

    for (i, row) in rows.iter().enumerate() {
        let cols: Vec<f64> = row
            .split(',')
            .map(|val| val.trim().parse::<f64>())
            .collect::<Result<Vec<_>, _>>()?;

        if i == 0 {
            col_count = cols.len();
        } else if cols.len() != col_count {
            return Err(format!("Inconsistent number of columns in line {}", i).into());
        }

        data.extend(cols);
    }

    // Explicit check for squareness
    if row_count != col_count {
        return Err(format!(
            "Matrix is not square ({}x{}). An A-matrix must be square for eigenvalue analysis.",
            row_count, col_count
        )
        .into());
    }

    // DMatrix is dynamic but satisfies SquareMatrix traits if row_count == col_count
    Ok(DMatrix::from_row_slice(row_count, col_count, &data))
}
